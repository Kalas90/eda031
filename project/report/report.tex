\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
\usepackage{graphicx}
\usepackage{sverb}
\usepackage{float}
\usepackage{verbatim}


\title{EDA031 | News project}
\author{Anton persson - atp10ape\\
		Elias Brange - tpi11ebr\\
		Johan FÃ¶rberg - atf10jfo\\
		Linus Hammarlund - atp10lha}
\begin{document}
\maketitle
\newpage

\section{System Design}

\subsection{Data representation}
Each article is represented by the \verb!Article! class, where each article has an author, title, text and an unique ID. Every article belongs to a newsgroup which are represented by the \verb!Newsgroup! class. Each newsgroup has an unique ID and a name, and all it's articles are represented in a vector.

\subsection{Server}
We have two different versions of the server, a in-memory one and a database one. The server receives messages from a connected client according to the protocol. If it receives a message not included in the protocol it throws a \verb!ProtocolViolationException!. If it receives an allowed message it tries to serve data to the client, and depending on the request the server either sends \verb!ANS_ACK! or \verb!ANS_NAK!. \verb!ANS_NAK! is sent when a client requests a newsgroup or article that does not exist, or when the client is trying to create a newsgroup with a name that already exists.

The persistent database server is implemented using a SQLITE3 database to save the data, and the in-memory one uses the data representation described above. We have an interface called \verb!NewsgroupProvider! that represents creating, removing and listing of newsgroups and articles, which is used in the two versions of the server.

Our server classes depends on the \verb!Server! class to handle sockets and low-level communication.

\subsection{Client}
The client is run using the \verb!Client! class, where all the logic is handled by the \verb!NewsClient! class. The client can basically have two states, one where the user has selected a news group and one where the user has not. Depending one which mode is entered the user can select a different number of commands.

When a command is received it's parsed by a function which in turn delegates the request to the correct sender function. After that the client waits to the response.

The response is saved into a string within the \verb!NewsClient! class by the \verb!receive()! function. Then it's parsed and printed by a separate function. This enables us to read the answer multiple times.

\subsection{Classes}
\begin{description}
\item[Article] Represents an article with an ID, author, title and text.
\item[Client] Generic client class, using methods from our \verb!NewsClient! class.
\item[Connection] Represents a connection between a server and a client.
\item[Database] Class implementing the \verb!NewsgroupProvider! interface for use with persistent data storage using SQLITE3.
\item[MemoryNewsGroupProvider] Class implementing the \verb!NewsgroupProvider! interface for use with in-memory data storage.
\item[NewsClient] Our class for sending and receiving messages to and from the server, and displaying the results in a text-based GUI. 
\item[NewsGroup] Represents a newsgroup with an ID and a unique name. Every newsgroup has a vector of articles.
\item[NewsGroupProvider] Interface containing methods for creating, removing and listing newsgroups and articles. Also has some custom exceptions such as \verb!MissingArticleException! and \verb!DuplicateNewsgroupException!.
\item[NewsServer] Our server that listens for messages from the client. Uses the protocol defined in \verb!Protocol! to serve correct data to the client. Uses the \verb!Server! class to establish connections with clients.
\item[Protocol] Class defining the protocol used by our system.
\item[Server] Generic server class that registers connection with clients.
\end{description}
\subsection{Communication}
The interaction between the server and a client is pretty straight-forward. The server listens for commands and when one is received it checks which type of command it received. If it received a faulty command it will throw and \verb!ProtocolViolationException!. If it receives a real command like \verb!COM_LIST_NG! it answers with \verb!ANS_LIST_NG! and it then fetches the newsgroups from the database and returns them to the client. If a request fails, like when asking for a newsgroup that does not exists, the server sends \verb!ANS_NAK! together with an error describing what went wrong.

Both the server and client uses functions like \verb!write_string! and \verb!write_num! that sends strings and numbers over the connection according to the protocol.


\section{Conclusions}
One conclusion we have drawn is that using a real database as back-end in one of the servers was easy and smooth. That way we did not have to implement an own system using e.g. files and folders to save our data.

Another thing we realised was that we should have spent more time planning in the beginning before we started coding. We had to rewrite a lot of the code on the server because we had not thought out all parts thoroughly. 

The project was fun and rewarding and we feel like we have solved all problems given in the project description.



\end{document}